---
phase: 71-renewable-installation-coal-retirement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - proto/worldmonitor/economic/v1/get_energy_capacity.proto
  - proto/worldmonitor/economic/v1/service.proto
  - server/worldmonitor/economic/v1/get-energy-capacity.ts
  - server/worldmonitor/economic/v1/handler.ts
  - src/services/economic/index.ts
  - src/services/renewable-energy-data.ts
autonomous: true
requirements:
  - ENERGY-01
  - ENERGY-03

must_haves:
  truths:
    - "GetEnergyCapacity RPC exists in the EconomicService proto and generated code compiles"
    - "Server handler fetches EIA state-electricity-profiles/capability data for SUN, WND, and coal sources, aggregates states to national totals by year"
    - "Client service function fetchEnergyCapacity() calls the RPC through a circuit breaker with feature gating on energyEia"
    - "Redis cache with 24h TTL prevents redundant EIA API calls for annual data"
  artifacts:
    - path: "proto/worldmonitor/economic/v1/get_energy_capacity.proto"
      provides: "GetEnergyCapacity request/response proto messages"
      contains: "GetEnergyCapacityRequest"
    - path: "server/worldmonitor/economic/v1/get-energy-capacity.ts"
      provides: "Server handler that fetches + aggregates EIA capacity data"
      exports: ["getEnergyCapacity"]
    - path: "src/services/renewable-energy-data.ts"
      provides: "Client-side fetchEnergyCapacity() function"
      exports: ["fetchEnergyCapacity"]
  key_links:
    - from: "server/worldmonitor/economic/v1/get-energy-capacity.ts"
      to: "https://api.eia.gov/v2/electricity/state-electricity-profiles/capability/data/"
      via: "fetch with API key and facet params"
      pattern: "api\\.eia\\.gov.*capability"
    - from: "server/worldmonitor/economic/v1/handler.ts"
      to: "server/worldmonitor/economic/v1/get-energy-capacity.ts"
      via: "handler registration"
      pattern: "getEnergyCapacity"
    - from: "src/services/renewable-energy-data.ts"
      to: "src/services/economic/index.ts"
      via: "fetchEnergyCapacity calling client RPC"
      pattern: "getEnergyCapacity"
---

<objective>
Add GetEnergyCapacity RPC to the EconomicService, implementing the full server-to-client data pipeline for EIA installed capacity data (solar, wind, coal).

Purpose: Provides the data backend for solar/wind growth and coal decline visualizations in the RenewableEnergyPanel. This is the data pipeline; the next plan handles visualization.

Output: Proto definitions, generated types, server handler, client service function — all wired and ready for the panel to consume.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/71-renewable-installation-coal-retirement/71-RESEARCH.md

@proto/worldmonitor/economic/v1/service.proto
@proto/worldmonitor/economic/v1/get_energy_prices.proto
@server/worldmonitor/economic/v1/get-energy-prices.ts
@server/worldmonitor/economic/v1/handler.ts
@src/services/economic/index.ts
@src/services/renewable-energy-data.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Proto definition + server handler for EIA capacity data</name>
  <files>
    proto/worldmonitor/economic/v1/get_energy_capacity.proto
    proto/worldmonitor/economic/v1/service.proto
    server/worldmonitor/economic/v1/get-energy-capacity.ts
    server/worldmonitor/economic/v1/handler.ts
  </files>
  <action>
    **1. Create proto file** `proto/worldmonitor/economic/v1/get_energy_capacity.proto`:

    ```protobuf
    syntax = "proto3";
    package worldmonitor.economic.v1;

    message GetEnergyCapacityRequest {
      // Energy source codes to query (e.g., "SUN", "WND", "COL").
      // Empty returns all tracked sources (SUN, WND, COL).
      repeated string energy_sources = 1;
      // Number of years of historical data. Default 20 if not set.
      int32 years = 2;
    }

    message EnergyCapacityYear {
      int32 year = 1;
      double capacity_mw = 2;
    }

    message EnergyCapacitySeries {
      string energy_source = 1;
      string name = 2;
      repeated EnergyCapacityYear data = 3;
    }

    message GetEnergyCapacityResponse {
      repeated EnergyCapacitySeries series = 1;
    }
    ```

    **2. Update service.proto** to add the new RPC:
    - Import `worldmonitor/economic/v1/get_energy_capacity.proto`
    - Add RPC: `rpc GetEnergyCapacity(GetEnergyCapacityRequest) returns (GetEnergyCapacityResponse)` with path `/get-energy-capacity`

    **3. Run proto codegen**: `cd proto && buf generate`
    Verify generated files exist at `src/generated/client/worldmonitor/economic/v1/service_client.ts` and `src/generated/server/worldmonitor/economic/v1/service_server.ts` — both should now export `GetEnergyCapacityRequest`, `GetEnergyCapacityResponse`, etc.

    **4. Create server handler** `server/worldmonitor/economic/v1/get-energy-capacity.ts`:

    Follow the exact pattern from `get-energy-prices.ts`:
    - `declare const process: { env: Record<string, string | undefined> };`
    - Import types from generated server code
    - Import `CHROME_UA` from `../../../_shared/constants`
    - Import `getCachedJson`, `setCachedJson` from `../../../_shared/redis`

    Constants:
    - `REDIS_CACHE_KEY = 'economic:capacity:v1'`
    - `REDIS_CACHE_TTL = 86400` (24h — annual data barely changes)
    - `DEFAULT_YEARS = 20`
    - `EIA_CAPACITY_SOURCES` array: `[{ code: 'SUN', name: 'Solar' }, { code: 'WND', name: 'Wind' }, { code: 'COL', name: 'Coal' }]`

    Core function `fetchCapacityForSource(sourceCode: string, apiKey: string, startYear: number)`:
    - Build URL: `https://api.eia.gov/v2/electricity/state-electricity-profiles/capability/data/`
    - URLSearchParams: `api_key`, `data[]=capability`, `frequency=annual`, `facets[energysourceid][]=<sourceCode>`, `sort[0][column]=period`, `sort[0][direction]=desc`, `length=5000`, `start=<startYear>`
    - Fetch with `AbortSignal.timeout(15000)` (longer timeout, large response)
    - Parse `response.response.data` array
    - Each row has `period` (string year), `stateid`, `capability` (MW number)
    - **Aggregate to national totals**: Group by `parseInt(period, 10)`, sum `capability` across all stateids for each year
    - Return `Map<number, number>` (year -> total US MW)

    **IMPORTANT — Coal code fallback**: If `COL` returns zero results, retry with codes `BIT`, `SUB`, `LIG`, `RC` separately and sum their national totals by year. This handles the case where the capability endpoint uses specific coal sub-type codes instead of an aggregate `COL` code. Implement as: try COL first; if result map is empty, fetch all 4 sub-types and merge.

    Export `getEnergyCapacity(ctx, req)`:
    - Read `process.env.EIA_API_KEY`, return empty response if missing
    - Compute `startYear = currentYear - (req.years || DEFAULT_YEARS)`
    - Filter `EIA_CAPACITY_SOURCES` by `req.energySources` if non-empty
    - Check Redis cache (key includes sorted source list + years)
    - For each source: call `fetchCapacityForSource`, build `EnergyCapacitySeries` with data sorted oldest-first
    - Cache result in Redis, return response

    **5. Register in handler.ts**:
    - Add import: `import { getEnergyCapacity } from './get-energy-capacity';`
    - Add to `economicHandler` object: `getEnergyCapacity,`
  </action>
  <verify>
    1. `cd proto && buf generate` succeeds without errors
    2. `grep -r "getEnergyCapacity" src/generated/` shows the RPC in both client and server generated files
    3. `npx tsc --noEmit` on the server handler file shows no type errors (or at minimum, the handler file imports resolve correctly)
  </verify>
  <done>
    GetEnergyCapacity RPC is defined in proto, generated code exists, server handler fetches EIA capacity data with state-level aggregation, coal code fallback, Redis caching (24h), and is registered in the economic handler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Client service function for energy capacity data</name>
  <files>
    src/services/economic/index.ts
    src/services/renewable-energy-data.ts
  </files>
  <action>
    **1. Add capacity circuit breaker and client function to `src/services/economic/index.ts`**:

    At the top, add to the existing imports from the generated client:
    - `GetEnergyCapacityResponse` (add to the existing import statement)

    Add a new circuit breaker after the existing `eiaBreaker`:
    ```typescript
    const capacityBreaker = createCircuitBreaker<GetEnergyCapacityResponse>({ name: 'EIA Capacity' });
    const emptyCapacityFallback: GetEnergyCapacityResponse = { series: [] };
    ```

    Add a new exported function at the end of the EIA section (before the World Bank section):
    ```typescript
    export async function fetchEnergyCapacityRpc(
      energySources?: string[],
      years?: number,
    ): Promise<GetEnergyCapacityResponse> {
      if (!isFeatureAvailable('energyEia')) return emptyCapacityFallback;
      try {
        return await capacityBreaker.execute(async () => {
          return client.getEnergyCapacity({
            energySources: energySources ?? [],
            years: years ?? 0,
          });
        }, emptyCapacityFallback);
      } catch {
        return emptyCapacityFallback;
      }
    }
    ```

    **2. Add `fetchEnergyCapacity()` to `src/services/renewable-energy-data.ts`**:

    Import the new RPC function:
    ```typescript
    import { fetchEnergyCapacityRpc } from '@/services/economic';
    ```

    Add exported types for the panel to consume:
    ```typescript
    export interface CapacityDataPoint {
      year: number;
      capacityMw: number;
    }

    export interface CapacitySeries {
      source: string;   // 'SUN', 'WND', 'COL'
      name: string;     // 'Solar', 'Wind', 'Coal'
      data: CapacityDataPoint[];
    }
    ```

    Add exported function:
    ```typescript
    export async function fetchEnergyCapacity(): Promise<CapacitySeries[]> {
      try {
        const resp = await fetchEnergyCapacityRpc(['SUN', 'WND', 'COL'], 25);
        return resp.series.map(s => ({
          source: s.energySource,
          name: s.name,
          data: s.data.map(d => ({ year: d.year, capacityMw: d.capacityMw })),
        }));
      } catch {
        return [];
      }
    }
    ```

    This function transforms proto types into clean domain types the panel can consume directly.
  </action>
  <verify>
    1. `npx tsc --noEmit` passes (or at minimum no errors in the modified files)
    2. `grep "fetchEnergyCapacity" src/services/renewable-energy-data.ts` shows the exported function
    3. `grep "fetchEnergyCapacityRpc" src/services/economic/index.ts` shows the RPC wrapper
  </verify>
  <done>
    Client-side `fetchEnergyCapacity()` function exists in renewable-energy-data.ts, calls the GetEnergyCapacity RPC through a circuit breaker with energyEia feature gating, and returns typed `CapacitySeries[]` ready for the panel to render.
  </done>
</task>

</tasks>

<verification>
1. Proto codegen produces valid types for GetEnergyCapacity RPC
2. Server handler is registered and would fetch from EIA API (cannot test live without running server, but TypeScript compiles)
3. Client function chain: renewable-energy-data.ts -> economic/index.ts -> generated client -> server handler -> EIA API
4. Feature gating: if energyEia is disabled, fetchEnergyCapacity returns empty array gracefully
5. Redis caching: 24h TTL on annual capacity data prevents excessive EIA API calls
</verification>

<success_criteria>
- `cd proto && buf generate` succeeds
- TypeScript compilation passes for all modified files
- `getEnergyCapacity` handler registered in economic service handler
- `fetchEnergyCapacity` exported from renewable-energy-data.ts
- No regressions in existing energy price or World Bank functionality
</success_criteria>

<output>
After completion, create `.planning/phases/71-renewable-installation-coal-retirement/71-01-SUMMARY.md`
</output>
